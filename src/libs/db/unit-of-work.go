package db

import (
	"context"
	"donation-mgmt/src/dal"
	"donation-mgmt/src/libs/logger"
	"donation-mgmt/src/system/logging"
	"errors"
	"fmt"
	"log/slog"
	"sync"
	"sync/atomic"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrUnitOfWorkReleased = errors.New("unit of work was released")
var ErrInitQuerier = errors.New("error initializing querier")

type UnitOfWork struct {
	l *slog.Logger

	withTx   bool
	released *atomic.Bool

	initOnce *sync.Once

	conn *pgxpool.Conn
	tx   pgx.Tx

	querier dal.Querier
}

// NewUnitOfWork creates a new UnitOfWork instance without any transaction
func NewUnitOfWork() *UnitOfWork {
	return &UnitOfWork{
		l: logger.ForComponent("UnitOfWork"),

		withTx:   false,
		released: &atomic.Bool{},

		initOnce: &sync.Once{},
	}
}

func NewUnitOfWorkWithTx() *UnitOfWork {
	var uow = NewUnitOfWork()
	uow.withTx = true

	return uow
}

// GetQuerier returns a querier object that can be used to interact with the database.
// The querier object is created lazily and is only created once per UnitOfWork instance.
func (uow *UnitOfWork) GetQuerier(ctx context.Context) (dal.Querier, error) {
	l := uow.l.With(logging.ContextLogData(ctx)...)

	if uow.released.Load() {
		return nil, ErrUnitOfWorkReleased
	}

	var err error
	uow.initOnce.Do(func() {
		l.Debug("Acquiring DB connection from the pool")
		uow.conn, err = DBPool().Acquire(ctx)
		if err != nil {
			// We handle errors outside of this doOnce block
			err = fmt.Errorf("error acquiring DB connection: %w", err)
			return
		}

		if uow.withTx {
			l.Debug("Initializing DB transaction...")
			uow.tx, err = uow.conn.Begin(ctx)
			if err != nil {
				// We handle errors outside of this doOnce block
				err = fmt.Errorf("error starting DB transaction: %w", err)
				return
			}

			// We create a new instance of the querier object generated by sqlc
			uow.querier = dal.New(uow.tx)
		} else {
			// We create a new instance of the querier object generated by sqlc
			uow.querier = dal.New(uow.conn)
		}
	})

	if err != nil {
		l.Error("Error initializing UnitOfWork", slog.Any("error", err))
		return nil, err
	}

	if uow.querier == nil {
		return nil, ErrInitQuerier
	}

	return uow.querier, nil
}

// Finalize rolls back the transaction as necessary and releases the DB connection. If a commit has already occured,
// this function will not do anything.
func (uow *UnitOfWork) Finalize(ctx context.Context) {
	l := uow.l.With(logging.ContextLogData(ctx)...)

	if uow.released.Load() {
		l.Debug("UnitOfWork already released. Nothing to do...")
		return
	}

	defer uow.Release(l)

	if uow.tx == nil {
		l.Debug("UnitOfWork does not have a transaction. Nothing to do...")
		return
	}

	if uow.tx != nil {
		l.Debug("Rolling back DB transaction")
		err := uow.tx.Rollback(ctx)
		if err != nil {
			l.Error("Error rolling back DB transaction", slog.Any("error", err))
		}
	}
}

// Commit the underlying transaction
func (uow *UnitOfWork) Commit(ctx context.Context) error {
	l := uow.l.With(logging.ContextLogData(ctx)...)

	if uow.released.Load() {
		l.Debug("UnitOfWork already released. Nothing to do...")
		return nil
	}

	defer uow.Release(l)

	if uow.tx == nil {
		l.Debug("UnitOfWork does not have a transaction. Nothing to do...")
		return nil
	}

	l.Debug("Commiting DB transaction")
	err := uow.tx.Commit(ctx)
	if err != nil {
		l.Error("Error commiting DB transaction", slog.Any("error", err))
		return err
	}

	return nil
}

// Release the connection back to the pool
func (uow *UnitOfWork) Release(l *slog.Logger) {
	if uow.conn == nil || uow.released.Load() {
		l.Debug("UnitOfWork already released. Nothing to do...")
	}

	defer func() {
		uow.conn.Release()
		uow.released.Store(true)

		l.Debug("Database connection released")
	}()
}
