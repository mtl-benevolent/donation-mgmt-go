package db

import (
	"context"
	"donation-mgmt/src/data_access"
	"donation-mgmt/src/libs/logger"
	"donation-mgmt/src/system/contextual"
	"errors"
	"log/slog"
	"sync"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

var ErrUnitOfWorkReleased = errors.New("unit of work was released")
var ErrInitQuerier = errors.New("error initializing querier")

type UnitOfWork struct {
	l *slog.Logger

	txRequested bool
	released    bool

	initOnce *sync.Once

	conn *pgxpool.Conn
	tx   pgx.Tx

	querier data_access.Querier
}

func NewUnitOfWork() *UnitOfWork {
	return &UnitOfWork{
		l: logger.ForComponent("UnitOfWork"),

		txRequested: false,
		released:    false,

		initOnce: &sync.Once{},
	}
}

func (uow *UnitOfWork) UseTransaction() {
	uow.txRequested = true
}

func (uow *UnitOfWork) WillUseTransaction() bool {
	return uow.txRequested
}

func (uow *UnitOfWork) GetQuerier(ctx context.Context) (data_access.Querier, error) {
	l := uow.l.With(contextual.ContextLogData(ctx)...)

	if uow.released {
		return nil, ErrUnitOfWorkReleased
	}

	var err error
	uow.initOnce.Do(func() {
		l.Debug("Acquiring DB connection from the pool")
		uow.conn, err = DBPool().Acquire(ctx)
		if err != nil {
			return
		}

		if uow.txRequested {
			l.Debug("Initializing DB transaction...")
			uow.tx, err = uow.conn.Begin(ctx)
			if err != nil {
				return
			}
			// We create a new instance of the querier object generated by sqlc
			uow.querier = data_access.New(uow.tx)
		} else {
			// We create a new instance of the querier object generated by sqlc
			uow.querier = data_access.New(uow.conn)
		}
	})

	if err != nil {
		l.Error("Error initializing UnitOfWork", slog.Any("error", err))
		return nil, err
	}

	if uow.querier == nil {
		return nil, ErrInitQuerier
	}

	return uow.querier, nil
}

// Finalize commits or rolls back the transaction (if necessary) and releases the database connection.
func (uow *UnitOfWork) Finalize(ctx context.Context, isSuccess bool) error {
	l := uow.l.With(contextual.ContextLogData(ctx)...)

	if uow.released {
		l.Debug("UnitOfWork already released. Nothing to do...")
		return nil
	}

	// UnitOfWork is lazy-loaded. If not used, we don't have anything to do.
	if uow.conn == nil {
		l.Debug("UnitOfWork already released. Nothing to do...")
		return nil
	}

	defer func() {
		uow.conn.Release()
		uow.released = true

		l.Debug("Database connection released")
	}()

	if uow.tx != nil {
		// Just in case...
		defer func(tx pgx.Tx, ctx context.Context) {
			_ = tx.Rollback(ctx)
		}(uow.tx, ctx)

		if isSuccess {
			l.Debug("Commiting DB transaction")
			err := uow.tx.Commit(ctx)
			if err != nil {
				l.Debug("Error commiting DB transaction", slog.Any("error", err))
				return err
			}
		} else {
			l.Debug("Rolling back DB transaction")
			err := uow.tx.Rollback(ctx)
			if err != nil {
				l.Debug("Error rolling back DB transaction", slog.Any("error", err))
				return err
			}
		}
	}

	return nil
}
